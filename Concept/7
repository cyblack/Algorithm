import random
from typing import List, Tuple, Dict, Optional

Point = Tuple[int, int]
BBox = Tuple[int, int, int, int]  # (xmin, ymin, xmax, ymax)

W = 1024
H = 1024

# ----------------- bbox / score -----------------
def bbox_of(pts: List[Point]) -> BBox:
    xs = [p[0] for p in pts]
    ys = [p[1] for p in pts]
    return (min(xs), min(ys), max(xs), max(ys))

def area(b: BBox) -> int:
    x1, y1, x2, y2 = b
    return (x2 - x1 + 1) * (y2 - y1 + 1)

def sum_sq(HH: int) -> int:
    return (HH - 1) * HH * (2 * HH - 1) // 6

def score_from_bboxes(bboxes: List[BBox]) -> float:
    HH = len(bboxes)
    if HH == 0:
        return float("-inf")
    add = sum_sq(HH)
    areas = [area(b) for b in bboxes]
    mu = sum(areas) / HH
    pen = sum(abs(a - mu) / 10.0 for a in areas)
    return add - pen

# ----------------- strict overlap (boundary touch counts as overlap) -----------------
def bbox_overlap_strict(b1: BBox, b2: BBox) -> bool:
    x1, y1, x2, y2 = b1
    a1, b1y, a2, b2y = b2
    # If not separated strictly, they overlap (boundary-touch included)
    if x2 < a1 or a2 < x1:
        return False
    if y2 < b1y or b2y < y1:
        return False
    return True

def check_overlaps_strict(bboxes: List[BBox], max_print: int = 10) -> int:
    cnt = 0
    n = len(bboxes)
    for i in range(n):
        for j in range(i + 1, n):
            if bbox_overlap_strict(bboxes[i], bboxes[j]):
                cnt += 1
                if cnt <= max_print:
                    print(f"[OVERLAP(strict)] {i} {bboxes[i]} <-> {j} {bboxes[j]}")
    return cnt

# ----------------- random points -----------------
def generate_random_points(n: int, seed: int = 42) -> List[Point]:
    rng = random.Random(seed)
    idxs = rng.sample(range(W * H), n)  # unique
    return [(i % W, i // W) for i in idxs]

# ----------------- strict strip split (avoid boundary touch on strip axis) -----------------
def split_into_strips_strict(points_sorted: List[Point], strip_size: int, mode: str) -> List[List[Point]]:
    """
    mode="H": points_sorted sorted by (y,x). Ensure strip boundary doesn't split same y.
    mode="V": points_sorted sorted by (x,y). Ensure strip boundary doesn't split same x.
    """
    n = len(points_sorted)
    strips: List[List[Point]] = []
    strip_size = max(4, strip_size)

    i = 0
    while i < n:
        cur: List[Point] = []

        if mode == "H":
            cur_axis_max = -1  # max y in current strip
            while i < n:
                x, y = points_sorted[i]
                # take until reaching strip_size, but also keep same-y together
                if len(cur) < strip_size:
                    cur.append((x, y))
                    cur_axis_max = max(cur_axis_max, y)
                    i += 1
                else:
                    # if next point has same y as current strip's max y, include it to avoid boundary-touch strips
                    if y == cur_axis_max:
                        cur.append((x, y))
                        i += 1
                    else:
                        break
        else:
            cur_axis_max = -1  # max x in current strip
            while i < n:
                x, y = points_sorted[i]
                if len(cur) < strip_size:
                    cur.append((x, y))
                    cur_axis_max = max(cur_axis_max, x)
                    i += 1
                else:
                    if x == cur_axis_max:
                        cur.append((x, y))
                        i += 1
                    else:
                        break

        # If we ended up with a tiny tail (<4), merge it into previous strip
        if strips and len(cur) < 4:
            strips[-1].extend(cur)
        else:
            strips.append(cur)

    return strips

# ----------------- build houses inside a strip with strict "no boundary touch" -----------------
def build_houses_in_strip_strict(strip_pts: List[Point], mode: str, direction: int) -> List[BBox]:
    """
    mode:
      "H": horizontal strips -> internal sweep along x
      "V": vertical strips   -> internal sweep along y
    direction:
      +1: H -> left->right,   V -> top->bottom
      -1: H -> right->left,   V -> bottom->top

    We form 4-point groups in that order, but if a new house would boundary-touch
    the previous house along the sweep axis, we merge it into the previous one.
    """
    assert mode in ("H", "V")
    assert direction in (+1, -1)

    # internal ordering
    if mode == "H":
        # sweep along x
        if direction == +1:  # left -> right
            pts = sorted(strip_pts, key=lambda p: (p[0], p[1]))
        else:                # right -> left
            pts = sorted(strip_pts, key=lambda p: (-p[0], p[1]))
        # conflict test along x: require prev_xmax < new_xmin (strict)
        def conflict(prev: BBox, new: BBox) -> bool:
            if direction == +1:
                return new[0] <= prev[2]   # new_xmin <= prev_xmax => touches/overlaps
            else:
                return new[2] >= prev[0]   # new_xmax >= prev_xmin => touches/overlaps
    else:
        # sweep along y
        if direction == +1:  # top -> bottom
            pts = sorted(strip_pts, key=lambda p: (p[1], p[0]))
        else:                # bottom -> top
            pts = sorted(strip_pts, key=lambda p: (-p[1], p[0]))
        # conflict test along y: require prev_ymax < new_ymin (strict)
        def conflict(prev: BBox, new: BBox) -> bool:
            if direction == +1:
                return new[1] <= prev[3]
            else:
                return new[3] >= prev[1]

    groups: List[List[Point]] = []
    bboxes: List[BBox] = []

    i = 0
    while i + 4 <= len(pts):
        g = pts[i:i + 4]
        bb = bbox_of(g)

        if not bboxes:
            groups.append(g)
            bboxes.append(bb)
        else:
            prev_bb = bboxes[-1]
            if conflict(prev_bb, bb):
                # merge into previous house
                groups[-1].extend(g)
                bboxes[-1] = bbox_of(groups[-1])
            else:
                groups.append(g)
                bboxes.append(bb)

        i += 4

    # leftover (1~3): append into last group (your "last rectangle absorbs leftovers")
    if i < len(pts):
        rem = pts[i:]
        if not bboxes:
            bboxes.append(bbox_of(rem))
        else:
            groups[-1].extend(rem)
            bboxes[-1] = bbox_of(groups[-1])

    return bboxes

# ----------------- solve one setting -----------------
def solve_strip_strict(points: List[Point], strip_size: int, mode: str, direction: int) -> Tuple[List[BBox], float]:
    if mode == "H":
        pts_sorted = sorted(points, key=lambda p: (p[1], p[0]))  # by y then x
    else:
        pts_sorted = sorted(points, key=lambda p: (p[0], p[1]))  # by x then y

    strips = split_into_strips_strict(pts_sorted, strip_size=strip_size, mode=mode)

    bboxes: List[BBox] = []
    for strip in strips:
        bboxes.extend(build_houses_in_strip_strict(strip, mode=mode, direction=direction))

    sc = score_from_bboxes(bboxes)
    return bboxes, sc

# ----------------- sweep modes/directions/sizes -----------------
def sweep_strict(points: List[Point],
                 strip_sizes=(40, 60, 80, 100, 120, 160),
                 modes=("H", "V"),
                 directions=(+1, -1),
                 require_no_overlap: bool = True):
    best = None  # (score, bboxes, meta)

    for mode in modes:
        for direction in directions:
            for s in strip_sizes:
                s4 = max(4, (s // 4) * 4)  # prefer multiple of 4
                bboxes, sc = solve_strip_strict(points, strip_size=s4, mode=mode, direction=direction)

                ov = check_overlaps_strict(bboxes, max_print=0)
                if require_no_overlap and ov != 0:
                    continue

                meta = {"mode": mode, "direction": direction, "strip_size": s4,
                        "houses": len(bboxes), "strict_overlaps": ov}

                if best is None or sc > best[0]:
                    best = (sc, bboxes, meta)

    return best

# ----------------- demo -----------------
if __name__ == "__main__":
    N = 2000
    pts = generate_random_points(N, seed=42)

    best = sweep_strict(
        pts,
        strip_sizes=(40, 60, 80, 100, 120, 160),
        modes=("H", "V"),
        directions=(+1, -1),
        require_no_overlap=True,
    )

    if best is None:
        print("No valid strict solution found.")
    else:
        best_score, best_bboxes, meta = best
        print("BEST score:", best_score)
        print("Meta:", meta)

        # Print some overlaps if any (should be 0 if require_no_overlap=True)
        ov = check_overlaps_strict(best_bboxes, max_print=5)
        print("Strict overlap pairs:", ov)
