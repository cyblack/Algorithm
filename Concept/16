from dataclasses import dataclass
import random
from collections import defaultdict
from typing import List, Dict, Tuple, Optional

CIRCLE = 1000
CAP_TRAIN = 100
CAP_STATION = 1000

def cw(a: int, b: int) -> int:
    return (b - a) % CIRCLE

def ccw(a: int, b: int) -> int:
    return (a - b) % CIRCLE

def best_dir_and_dist(a: int, b: int) -> Tuple[int, int]:
    """return (dir, dist) where dir=+1 means cw, dir=-1 means ccw, dist>=0"""
    d1 = cw(a, b)
    d2 = ccw(a, b)
    if d1 <= d2:
        return +1, d1
    else:
        return -1, d2

@dataclass
class Cargo:
    cid: int
    origin: int
    dest: int
    weight: int

class World:
    def __init__(self, station_pos: List[int], cargos: List[Cargo]):
        self.station_pos = station_pos              # position per station index
        self.n = len(station_pos)
        self.cargos = {c.cid: c for c in cargos}

        # where each cargo currently is: station index, or None if on train, or dest delivered flag
        self.at_station: Dict[int, int] = {c.cid: c.origin for c in cargos}
        self.delivered = set()

        self.station_inventory: List[List[int]] = [[] for _ in range(self.n)]
        for c in cargos:
            self.station_inventory[c.origin].append(c.cid)

        self.train_pos_station = 0  # train is always at some station index in this model
        self.train_load: List[int] = []
        self.cost = 0

    def train_weight(self) -> int:
        return sum(self.cargos[cid].weight for cid in self.train_load)

    def Move(self, dist: int):
        # dist can be negative, but we model station-to-station moves only.
        w = self.train_weight()
        self.cost += (w + 50) * (abs(dist) + 10)

    def Load(self, cid: int):
        s = self.train_pos_station
        # must be at same station
        assert self.at_station.get(cid) == s
        w = self.train_weight()
        assert w + self.cargos[cid].weight <= CAP_TRAIN
        # remove from station inventory
        self.station_inventory[s].remove(cid)
        self.at_station[cid] = None
        self.train_load.append(cid)

    def Unload(self, cid: int):
        s = self.train_pos_station
        assert cid in self.train_load
        # station capacity check (count of cargos there)
        assert len(self.station_inventory[s]) < CAP_STATION
        self.train_load.remove(cid)
        c = self.cargos[cid]
        if c.dest == s:
            self.delivered.add(cid)
            self.at_station.pop(cid, None)
        else:
            self.at_station[cid] = s
            self.station_inventory[s].append(cid)

    def done(self) -> bool:
        return len(self.delivered) == len(self.cargos)

def pick_loads_greedy(world: World, direction: Optional[int]):
    """Load cargos at current station. If direction is given (+1 cw / -1 ccw), prefer those aligned."""
    s = world.train_pos_station
    cur_pos = world.station_pos[s]

    # candidate cargos at station
    cids = list(world.station_inventory[s])

    def aligned_score(cid: int) -> Tuple[int, int, int]:
        c = world.cargos[cid]
        dst_pos = world.station_pos[c.dest]
        if direction is None:
            # neutral: prefer nearer destinations (min distance), heavier later (since heavier increases cost)
            d = min(cw(cur_pos, dst_pos), ccw(cur_pos, dst_pos))
            return (d, c.weight, cid)
        else:
            d = cw(cur_pos, dst_pos) if direction == +1 else ccw(cur_pos, dst_pos)
            # prefer smaller d, and if same d prefer heavier (deliver heavy quickly)
            return (d, -c.weight, cid)

    cids.sort(key=aligned_score)

    for cid in cids:
        if cid in world.delivered:
            continue
        w = world.train_weight()
        cwgt = world.cargos[cid].weight
        if w + cwgt <= CAP_TRAIN:
            world.Load(cid)

def unload_deliveries(world: World):
    """Unload anything whose destination is here."""
    s = world.train_pos_station
    for cid in list(world.train_load):
        if world.cargos[cid].dest == s:
            world.Unload(cid)

def maybe_buffer_unload(world: World, next_dir: int, far_threshold: int = 250):
    """Optional: unload cargos that are 'too far' along chosen direction to reduce W before long haul."""
    s = world.train_pos_station
    cur_pos = world.station_pos[s]
    for cid in list(world.train_load):
        c = world.cargos[cid]
        dst_pos = world.station_pos[c.dest]
        d = cw(cur_pos, dst_pos) if next_dir == +1 else ccw(cur_pos, dst_pos)
        if d > far_threshold:
            # drop as buffer if station has room
            if len(world.station_inventory[s]) < CAP_STATION:
                world.Unload(cid)

def choose_next_station(world: World) -> Tuple[int, int]:
    """Return (next_station_index, signed_dist)"""
    s = world.train_pos_station
    cur_pos = world.station_pos[s]

    # If carrying, go to nearest destination among carried cargos
    if world.train_load:
        best = None
        for cid in world.train_load:
            dst = world.cargos[cid].dest
            dir_, d = best_dir_and_dist(cur_pos, world.station_pos[dst])
            val = (d, dst)
            if best is None or val < best:
                best = val
        _, nxt = best
        dir_, d = best_dir_and_dist(cur_pos, world.station_pos[nxt])
        signed = d if dir_ == +1 else -d
        return nxt, signed

    # If empty, go to station with best pickup potential / (dist+10)
    best_score = None
    best_choice = None
    for j in range(world.n):
        if j == s:
            continue
        inv = world.station_inventory[j]
        if not inv:
            continue
        # pickup potential: total weight of top cargos that can fit within 100 (greedy)
        weights = sorted((world.cargos[cid].weight for cid in inv))
        tot = 0
        for w in weights:
            if tot + w <= CAP_TRAIN:
                tot += w
        if tot == 0:
            continue

        dir_, d = best_dir_and_dist(cur_pos, world.station_pos[j])
        score = tot / (d + 10)
        if best_score is None or score > best_score:
            best_score = score
            signed = d if dir_ == +1 else -d
            best_choice = (j, signed)

    if best_choice is None:
        # no inventory anywhere? then must be all delivered (or buffered on stations but not visible) - fallback
        # choose any station that still has undelivered cargo sitting
        for j in range(world.n):
            if world.station_inventory[j]:
                dir_, d = best_dir_and_dist(cur_pos, world.station_pos[j])
                signed = d if dir_ == +1 else -d
                return j, signed
        return s, 0

    return best_choice

def solve_greedy(world: World, step_limit: int = 200000):
    for _ in range(step_limit):
        if world.done():
            return

        # 1) unload deliveries
        unload_deliveries(world)

        # 2) choose next station plan (based on current state)
        nxt, signed_dist = choose_next_station(world)
        if nxt == world.train_pos_station and signed_dist == 0:
            # try loading something here if empty plan
            pick_loads_greedy(world, direction=None)
            unload_deliveries(world)
            if world.done():
                return
            nxt, signed_dist = choose_next_station(world)
            if nxt == world.train_pos_station and signed_dist == 0:
                break

        next_dir = +1 if signed_dist >= 0 else -1

        # 3) optional buffering before long move
        if abs(signed_dist) > 200 and world.train_load:
            maybe_buffer_unload(world, next_dir, far_threshold=250)

        # 4) load (prefer aligned to move direction)
        pick_loads_greedy(world, direction=next_dir)

        # 5) move and arrive
        world.Move(signed_dist)
        world.train_pos_station = nxt

    raise RuntimeError("step_limit reached; heuristic got stuck")

def random_instance(seed=0,
                    n_stations=80,
                    cargos_per_station_range=(30, 100)) -> World:
    random.seed(seed)
    # choose unique positions
    pos = sorted(random.sample(range(CIRCLE), n_stations))
    cargos = []
    cid = 0
    for s in range(n_stations):
        k = random.randint(*cargos_per_station_range)
        for _ in range(k):
            dest = random.randrange(n_stations)
            while dest == s:
                dest = random.randrange(n_stations)
            # half: 1~50, half: 1~100
            if random.random() < 0.5:
                w = random.randint(1, 50)
            else:
                w = random.randint(1, 100)
            cargos.append(Cargo(cid=cid, origin=s, dest=dest, weight=w))
            cid += 1
    return World(pos, cargos)

if __name__ == "__main__":
    w = random_instance(seed=42, n_stations=60)
    solve_greedy(w)
    print("delivered:", len(w.delivered), "cost:", w.cost)
