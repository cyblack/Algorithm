import random
from typing import List, Tuple, Dict, Optional

Point = Tuple[int, int]
BBox  = Tuple[int, int, int, int]  # (xmin, ymin, xmax, ymax)

W = 1024
H = 1024

# ----------------- scoring utils -----------------
def bbox_of(points: List[Point]) -> BBox:
    xs = [p[0] for p in points]
    ys = [p[1] for p in points]
    return (min(xs), min(ys), max(xs), max(ys))

def area(b: BBox) -> int:
    x1,y1,x2,y2 = b
    return (x2-x1+1) * (y2-y1+1)

def sum_sq(HH: int) -> int:
    return (HH - 1) * HH * (2*HH - 1) // 6

def score_from_bboxes(bboxes: List[BBox]) -> float:
    HH = len(bboxes)
    if HH == 0:
        return float("-inf")
    add = sum_sq(HH)
    areas = [area(b) for b in bboxes]
    mu = sum(areas) / HH
    pen = sum(abs(a - mu) / 10.0 for a in areas)
    return add - pen

# ----------------- overlap check -----------------
def bbox_overlap(b1: BBox, b2: BBox, include_boundary: bool = False) -> bool:
    """
    include_boundary=False: 경계 접촉은 OK, 내부가 겹칠 때만 overlap
    include_boundary=True : 경계가 닿아도 overlap 처리(엄격)
    """
    x1,y1,x2,y2 = b1
    a1,b1y,a2,b2y = b2

    if include_boundary:
        if x2 < a1 or a2 < x1: return False
        if y2 < b1y or b2y < y1: return False
        return True
    else:
        if x2 <= a1 or a2 <= x1: return False
        if y2 <= b1y or b2y <= y1: return False
        return True

def check_overlaps(bboxes: List[BBox], include_boundary: bool = False, max_print: int = 5) -> int:
    cnt = 0
    n = len(bboxes)
    for i in range(n):
        for j in range(i+1, n):
            if bbox_overlap(bboxes[i], bboxes[j], include_boundary=include_boundary):
                cnt += 1
                if cnt <= max_print:
                    print(f"[OVERLAP] {i} {bboxes[i]} <-> {j} {bboxes[j]}")
    return cnt

# ----------------- random points -----------------
def generate_random_points(n: int, seed: int = 42) -> List[Point]:
    rng = random.Random(seed)
    idxs = rng.sample(range(W * H), n)
    return [(i % W, i // W) for i in idxs]

# ----------------- strip builder -----------------
def split_into_strips(points_sorted: List[Point], strip_size: int) -> List[List[Point]]:
    """
    points_sorted: 정렬된 점 리스트 (가로스트립이면 y정렬, 세로스트립이면 x정렬)
    strip_size: 스트립당 목표 개수(가능하면 4의 배수 추천)
    """
    n = len(points_sorted)
    strips: List[List[Point]] = []

    # strip_size는 최소 4 이상
    strip_size = max(4, strip_size)

    i = 0
    while i < n:
        remain = n - i
        if remain <= strip_size:
            # 마지막 스트립
            strips.append(points_sorted[i:])
            break

        # 중간 스트립은 strip_size로 자르되, 다음이 너무 작으면( <4 ) 현재에 흡수
        take = strip_size
        if remain - take < 4:
            take = remain  # 다 가져가서 마지막 한 스트립으로 처리

        strips.append(points_sorted[i:i+take])
        i += take

    return strips

def build_houses_in_strip(strip_pts: List[Point], axis: str) -> List[BBox]:
    """
    axis:
      - "H": horizontal strip (y-bands) -> 내부는 x로 정렬해서 연속 4개씩
      - "V": vertical strip (x-bands)   -> 내부는 y로 정렬해서 연속 4개씩
    규칙:
      - 4개씩 그룹
      - 마지막 자투리(1~3)는 마지막 그룹에 합쳐서 (그 스트립의 가장 끝쪽 그룹이라 충돌 위험 낮음)
    """
    if axis == "H":
        pts = sorted(strip_pts, key=lambda p: (p[0], p[1]))  # x 오름차순
    else:
        pts = sorted(strip_pts, key=lambda p: (p[1], p[0]))  # y 오름차순

    bboxes: List[BBox] = []
    m = len(pts)
    q = (m // 4) * 4

    # 4개씩
    for i in range(0, q, 4):
        g = pts[i:i+4]
        bboxes.append(bbox_of(g))

    # 남는 자투리 -> 마지막 박스에 추가(요청 스타일)
    rem = pts[q:]
    if rem:
        if not bboxes:
            bboxes.append(bbox_of(rem))
        else:
            # 마지막 박스 확장
            x1,y1,x2,y2 = bboxes[-1]
            xs = [p[0] for p in rem]
            ys = [p[1] for p in rem]
            bboxes[-1] = (min(x1, min(xs)), min(y1, min(ys)), max(x2, max(xs)), max(y2, max(ys)))

    return bboxes

# ----------------- main: strip solve -----------------
def solve_strip(points: List[Point], strip_size: int, mode: str = "H") -> Tuple[List[BBox], float]:
    """
    mode:
      "H": horizontal strips by y (non-overlap between strips guaranteed by y-band separation)
      "V": vertical strips by x
    """
    if mode == "H":
        pts_sorted = sorted(points, key=lambda p: (p[1], p[0]))  # y, x
    else:
        pts_sorted = sorted(points, key=lambda p: (p[0], p[1]))  # x, y

    strips = split_into_strips(pts_sorted, strip_size=strip_size)

    bboxes: List[BBox] = []
    for strip in strips:
        bboxes.extend(build_houses_in_strip(strip, axis=mode))

    sc = score_from_bboxes(bboxes)
    return bboxes, sc

def sweep_strip(points: List[Point],
                strip_sizes=(40, 60, 80, 100, 120),
                modes=("H", "V"),
                include_boundary_overlap_check: bool = False):
    best = None  # (score, bboxes, meta)

    for mode in modes:
        for s in strip_sizes:
            # strip_size는 4의 배수로 맞추는 걸 추천
            s4 = max(4, (s // 4) * 4)
            bboxes, sc = solve_strip(points, strip_size=s4, mode=mode)

            ov = check_overlaps(bboxes, include_boundary=include_boundary_overlap_check, max_print=0)
            meta = {"mode": mode, "strip_size": s4, "houses": len(bboxes), "overlaps": ov}

            # 겹침이 있으면(엄격 조건) 버리기
            if ov != 0:
                continue

            if best is None or sc > best[0]:
                best = (sc, bboxes, meta)

    return best

# ----------------- demo -----------------
if __name__ == "__main__":
    pts = generate_random_points(2000, seed=42)

    best = sweep_strip(
        pts,
        strip_sizes=(40, 60, 80, 100, 120, 160),
        modes=("H", "V"),
        include_boundary_overlap_check=False  # 경계 접촉 허용(권장)
    )

    if best is None:
        print("No valid solution found (overlap constraint too strict).")
    else:
        best_score, best_bboxes, meta = best
        print("BEST score:", best_score)
        print("Meta:", meta)

        # 겹침 검증 출력
        ov = check_overlaps(best_bboxes, include_boundary=False, max_print=5)
        print("Overlap pairs:", ov)
